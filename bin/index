#!/usr/bin/env node

const { version } = require('../package.json')
const {
  traceMany, getUnion, getIntersection, implodeBundleDependencies, formatMilliseconds
} = require('../lib')

const args = process.argv
// node, this script and at least one module to trace its dependencies
if (args.length < 3) usage()

const modules = []
let rootDir, config, common, implodeBundles, explodeBundles, implodeCurrentBundle

// iterate over all arguments staring after the node and script
for (let i = 2, l = args.length; i < l; ++i) {
  const arg = args[i]
  let match
  // recognize -name or --name
  if ((match = /^(?:-|--)([-_a-zA-Z0-9]+)$/.exec(arg))) {
    switch (match[1]) {
      case 'r': case 'rootdir':
        rootDir = args[++i].trim()
        continue
      case 'c': case 'config':
        config = args[++i].trim()
        continue
      case 'common':
        common = true
        continue
      case 'implode-bundles':
        implodeBundles = true
        continue
      case 'explode-bundles':
        explodeBundles = args[++i].trim().split(/\s*,\s*/)
        continue
      case 'implode-current-bundle':
        implodeCurrentBundle = true
        continue
      case 'V': case 'version':
        process.stdout.write(`${version}
`)
        process.exit(0)
      case 'h': case 'help':
        usage()
    }
    fail(`Unknown option: "${match[0]}".`)
  }
  // arguments not starting with dash are module names
  modules.push(arg)
}

if (!modules.length) fail('No module supplied.')

traceMany({ modules, rootDir, config })
  .then(({ traced, config, time }) => {
    if (implodeBundles) {
      traced = implodeBundleDependencies({
        traced, bundles: config.bundles, explodeBundles, implodeCurrentBundle
      })
    }
    // if more than one originating module was entered, merge their dependencies
    if (modules.length > 1) {
      const method = common ? getIntersection : getUnion
      traced = method(traced)
    } else {
      traced = traced[modules[0]]
    }
    for (const { id } of traced) {
      process.stdout.write(`${id}
`)
    }
    const prefix = modules.length > 1 ? `${modules.length} modules` : modules[0]
    process.stderr.write(`${prefix} traced in ${formatMilliseconds(time)}
`)
  })
  .catch(({ message }) => fail(message))

function usage () {
  process.stdout.write(`Prints direct and indirect dependencies of one or more RequireJS modules.

Usage: requirejs-dependencies [option...] <module>...

Options:
  -r|--rootdir <path>       source root directory
  -c|--config <path>        configuration file for RequireJS
  --common                  print only common dependencies for more modules
  --implode-bundles         print bundles as dependencies instead of modules
  --explode-bundles <list>  specify bundles which modules will remain listed
  --implode-current-bundle  do not list dependencies from the same bundle
  -V|--version              print version number
  -h|--help                 print usage instructions

If you enable the option implode-bundles, you need to include bundles
in your config, so that relations module <--> bundle can be built.

If no arguments are provided, usage instructions will be printed out.
Errors and timing are printed on standard error. Dependencies, usage
instructions and version number are printed on standard output.

A non-zero exit code is returned in case of error.

Examples:
  requirejs-dependencies -r src -c src/config.js src/main
  requirejs-dependencies -r src --common src/store src/shell
`)
  process.exit(0)
}

function fail (message) {
  process.stderr.write(`${message}
`)
  process.exit(1)
}
